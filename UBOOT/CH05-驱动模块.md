[TOC]

# 驱动模块

## 1 Interrupt

### 1.1 框架支持

U-Boot 原生代码没有中断框架，RK 自己实现了一套用于支持 GICv2/v3，默认使能。

目前用到中断的场景：

- Pwrkey：U-Boot 充电时 CPU 会进入低功耗休眠，需要通过Pwrkey 中断唤醒 CPU；
- Timer：U-Boot 充电和测试用例中会用到 Timer 中断；
- Debug：使能 CONFIG_ROCKCHIP_DEBUGGER 调试功能；

配置：

```
CONFIG_IRQ
CONFIG_GICV2
CONFIG_GICV3
```

框架代码：

```
./drivers/irq/irq-gpio-switch.c
./drivers/irq/irq-gpio.c
./drivers/irq/irq-generic.c
./drivers/irq/irq-gic.c
./drivers/irq/virq.c
./include/irq-generic.h
```

### 1.2 相关接口

```c
// CPU本地中断开关
void enable_interrupts(void);
int disable_interrupts(void);

// GPIO转换成中断号
int gpio_to_irq(struct gpio_desc *gpio);
int phandle_gpio_to_irq(u32 gpio_phandle, u32 pin);
int hard_gpio_to_irq(unsigned gpio);

// 注册/释放中断回调
void irq_install_handler(int irq, interrupt_handler_t *handler, void *data);
void irq_free_handler(int irq);

// 使能/关闭中断
int irq_handler_enable(int irq);
int irq_handler_disable(int irq);

// 中断触发类型
int irq_set_irq_type(int irq, unsigned int type);
```

**申请 IRQ**

- 拥有独立硬件中断号的外设不需要额外转换，例如：pwm, timer等。
- GPIO 的 pin 脚没有独立的硬件中断号，需要额外转换申请。

一共有 3 种方式申请 GPIO 的 pin 脚中断号：

（1）传入 `struct gpio_desc` 结构体

```c
// 此方法可以动态解析dts配置，比较灵活、常用。
int gpio_to_irq(struct gpio_desc *gpio);
```

范例：

```c
battery {
	compatible = "battery,rk817";
	......
	dc_det_gpio = <&gpio2 7 GPIO_ACTIVE_LOW>;
	......
};
```

```c
struct gpio_desc dc_det;
int ret, irq;

ret = gpio_request_by_name_nodev(dev_ofnode(dev), "dc_det_gpio", 0,
                                 &dc_det, GPIOD_IS_IN);
// 为了示例简单，省去返回值判断
if (!ret) {
	irq = gpio_to_irq(&dc_det);
	irq_install_handler(irq, ...);
	irq_set_irq_type(irq, IRQ_TYPE_EDGE_FALLING);
	irq_handler_enable(irq);
}
```

（2）传入 gpio 的 phandle 和 pin

```c
// 此方法可以动态解析dts配置，比较灵活、常用。
int phandle_gpio_to_irq(u32 gpio_phandle, u32 pin);
```

范例（rk817 的中断引脚为 GPIO0_A7）：

```c
rk817: pmic@20 {
	compatible = "rockchip,rk817";
	reg = <0x20>;
	......
	interrupt-parent = <&gpio0>;             // "&gpio0": 指向gpio0节点的phandle；
	interrupts = <7 IRQ_TYPE_LEVEL_LOW>;     // "7": pin脚；
	......
};
```

```c
u32 interrupt[2], phandle;
int irq, ret;

phandle = dev_read_u32_default(dev->parent, "interrupt-parent", -1);
if (phandle < 0) {
	printf("failed get 'interrupt-parent', ret=%d\n", phandle);
	return phandle;
}

ret = dev_read_u32_array(dev->parent, "interrupts", interrupt, 2);
if (ret) {
	printf("failed get 'interrupt', ret=%d\n", ret);
	return ret;
}

// 为了示例简单，省去返回值判断
irq = phandle_gpio_to_irq(phandle, interrupt[0]);
irq_install_handler(irq, pwrkey_irq_handler, dev);
irq_set_irq_type(irq, IRQ_TYPE_EDGE_FALLING);
irq_handler_enable(irq);
```

（3）强制指定 gpio

```c
// 此方法直接强制指定 gpio，传入的 gpio 必须通过特殊的宏来声明才行，不够灵活，不建议使用。
int hard_gpio_to_irq(unsigned gpio);
```

范例（GPIO0_A0 申请中断）：

```c
int gpio0_a0, irq;

// 为了示例简单，省去返回值判断
gpio0_a0 = RK_IRQ_GPIO(RK_GPIO0, RK_PA0);
irq = hard_gpio_to_irq(gpio0_a0);
irq_install_handler(irq, ...);
irq_handler_enable(irq);
```

## 2 Clock

### 2.1 框架支持

clock 驱动使用 clk-uclass 框架和标准接口。

配置：

```
CONFIG_CLK
```

框架代码：

```
./drivers/clk/clk-uclass.c
```

平台驱动代码：

```
./drivers/clk/rockchip/...
```

### 2.2 相关接口

```c
// 申请时钟
int clk_get_by_index(struct udevice *dev, int index, struct clk *clk);
int clk_get_by_name(struct udevice *dev, const char *name, struct clk *clk);

// 使能/关闭时钟
int clk_enable(struct clk *clk);
int clk_disable(struct clk *clk);

// 配置/获取频率
ulong (*get_rate)(struct clk *clk);
ulong (*set_rate)(struct clk *clk, ulong rate);

// 配置/获取相位
int (*get_phase)(struct clk *clk);
int (*set_phase)(struct clk *clk, int degrees);
```

### 2.3 时钟初始化

一共有三类接口涉及时钟初始化，如下先列出cru节点的信息，方便后续介绍。

```
cru: clock-controller@ff2b0000 {
	compatible = "rockchip,px30-cru";
	......
	assigned-clocks =
		<&pmucru PLL_GPLL>, <&pmucru PCLK_PMU_PRE>,
		<&pmucru SCLK_WIFI_PMU>, <&cru ARMCLK>,
		<&cru ACLK_BUS_PRE>, <&cru ACLK_PERI_PRE>,
		<&cru HCLK_BUS_PRE>, <&cru HCLK_PERI_PRE>,
		<&cru PCLK_BUS_PRE>, <&cru SCLK_GPU>;
	assigned-clock-rates =
		<1200000000>, <100000000>,
		<26000000>, <600000000>,
		<200000000>, <200000000>,
		<150000000>, <150000000>,
		<100000000>, <200000000>;
	......
}
```

**第一类，平台基础时钟默认初始化：`rkclk_init()`**

各平台cru驱动probe会调用`rkclk_init()`完成 pll/cpu/bus 频率初始化，频率定义在 `cru_rkxxx.h` 。例如 RK3399：

```c
#define APLL_HZ         (600 * MHz)
#define GPLL_HZ         (800 * MHz)
#define CPLL_HZ         (384 * MHz)
#define NPLL_HZ         (600 * MHz)
#define PPLL_HZ         (676 * MHz)
#define PMU_PCLK_HZ     ( 48 * MHz)
#define ACLKM_CORE_HZ   (300 * MHz)
#define ATCLK_CORE_HZ   (300 * MHz)
#define PCLK_DBG_HZ     (100 * MHz)
#define PERIHP_ACLK_HZ  (150 * MHz)
#define PERIHP_HCLK_HZ  ( 75 * MHz)
#define PERIHP_PCLK_HZ  (37500 * KHz)
#define PERILP0_ACLK_HZ (300 * MHz)
#define PERILP0_HCLK_HZ (100 * MHz)
#define PERILP0_PCLK_HZ ( 50 * MHz)
#define PERILP1_HCLK_HZ (100 * MHz)
#define PERILP1_PCLK_HZ ( 50 * MHz)
......
```

**第二类，平台基础时钟二次初始化：`clk_set_defaults()`**

各平台cru驱动probe可能会调用`clk_set_defaults()`解析且配置cru节点内`assigned-clocks/assigned-clock-parents/assigned-clock-rates`指定的频率（即重新配置频率），但是不包括arm频率。仅当实现`set_armclk_rate()` 时才会配置。

除了cru之外，有需求的外设也可以在自己的probe里主动调用 `clk_set_defaults()`，例如 vop、gmac。

**第三类，各模块时钟初始化：`clk_set_rate()`**

大部分外设模块都是调用`clk_set_rate()` 配置自己的频率。

### 2.4 CPU提频

cpu开机提频的实现流程：

- 步骤1：cru 节点的 `assigned-clocks`里指定 arm 目标频率；
- 步骤2：cru 驱动probe时调用 `clk_set_defaults()` 获取（但不会配置）步骤1的arm目标频率；
- 步骤3：实现 `set_armclk_rate()` ，这是一个 __weak函数，它会配置从步骤2获取的 arm 目标频率；
- 步骤4：arm 的 regulator 节点增加`regulator-init-microvolt = <...>` 指定init电压避免电压不足；

### 2.5 时钟树

U-Boot 框架没有提供时钟树管理，各平台增加了`soc_clk_dump()` 用于简单打印时钟信息。例如：

````
CLK: (sync kernel. arm: enter 1200000 KHz, init 1200000 KHz, kernel 800000 KHz)
  apll 800000 KHz
  dpll 392000 KHz
  cpll 1000000 KHz
  gpll 1188000 KHz
  npll 24000 KHz
  ppll 100000 KHz
  hsclk_bus 297000 KHz
  msclk_bus 198000 KHz
  lsclk_bus 99000 KHz
  msclk_peri 198000 KHz
  lsclk_peri 99000 KHz
````

第一行打印的含义：

- `sync kernel`：cru 驱动通过 `clk_set_defaults()`  配置了 kernel cru 节点内指定的各总线频率（arm 频率除外）；否则显示为sync uboot；
- `enter 1200000 KHz`：前级 Loader 进入 U-Boot 时的 arm 频率；
- `init 1200000 KHz`：U-Boot 的 arm 初始化频率，即 APLL_HZ 定义的频率；
- `kernel 800000 KHz`：实现了 set_armclk_rate() 并设置了 kernel cru 节点里 `assigned-clocks` 指定的 arm 频率；否则显示："kernel 0N/A"；

## 3 GPIO

### 3.1 框架支持

GPIO 驱动使用 gpio-uclass 框架和标准接口，用户必须通过 `struct gpio_desc`才能访问到gpio。

配置：

```
CONFIG_DM_GPIO
CONFIG_ROCKCHIP_GPIO
```

框架代码：

```
./drivers/gpio/gpio-uclass.c
```

驱动代码：

```
./drivers/gpio/rk_gpio.c
```

### 3.2 相关接口

```c
// 申请/释放GPIO
int gpio_request_by_name(struct udevice *dev, const char *list_name,
                         int index, struct gpio_desc *desc, int flags);
int gpio_request_by_name_nodev(ofnode node, const char *list_name, int index,
                               struct gpio_desc *desc, int flags);
int gpio_request_list_by_name(struct udevice *dev, const char *list_name,
                              struct gpio_desc *desc_list, int max_count, int flags);
int gpio_request_list_by_name_nodev(ofnode node, const char *list_name,
                                    struct gpio_desc *desc_list, int max_count,
                                    int flags);
int dm_gpio_free(struct udevice *dev, struct gpio_desc *desc)

// 配置GPIO方向。@flags：GPIOD_IS_OUT（输出）和 GPIOD_IS_IN（输入）
int dm_gpio_set_dir_flags(struct gpio_desc *desc, ulong flags);

// 设置/获取GPIO电平
int dm_gpio_get_value(const struct gpio_desc *desc)
int dm_gpio_set_value(const struct gpio_desc *desc, int value)
```

**注意事项：**

`dm_gpio_get_value()` 的返回值表示active状态，而非电平的高或低。例如：

- gpios = <&gpio2 RK_PD0 GPIO_ACTIVE_LOW>，低电平时返回值为 1，高电平为 0。

- gpios = <&gpio2 RK_PD0 GPIO_ACTIVE_HIGH>，低电平时返回值为 0，高电平为 1。

`dm_gpio_set_value()` 的参数value也是同理，1：atcive，0：inactive。

## 4 Pinctrl

### 4.1 框架支持

pinctrl 驱动使用 pinctrl-uclass 框架和标准接口。

配置：

```
CONFIG_PINCTRL_GENERIC
CONFIG_PINCTRL_ROCKCHIP
```

框架代码：

```
./drivers/pinctrl/pinctrl-uclass.c
```

驱动代码：

```
./drivers/pinctrl/pinctrl-rockchip.c
```

### 4.2 相关接口

```c
int pinctrl_select_state(struct udevice *dev, const char *statename)    // 设置状态
int pinctrl_get_gpio_mux(struct udevice *dev, int banknum, int index)   // 获取状态
```

pinctrl 框架会在各个driver probe 时又框架自动为其设置"default"状态，用户一般不需要调用pinctrl接口。

## 5 I2C

### 5.1 框架支持

i2c 驱动使用 i2c-uclass 框架和标准接口。

配置：

```
CONFIG_DM_I2C
CONFIG_SYS_I2C_ROCKCHIP
```

框架代码：

```
./drivers/i2c/i2c-uclass.c
```

驱动代码：

```c
./drivers/i2c/rk_i2c.c
./drivers/i2c/i2c-gpio.c    // gpio模拟i2c通讯，目前用不到
```

### 5.2 相关接口

```c
// i2c 读写
int dm_i2c_read(struct udevice *dev, uint offset, uint8_t *buffer, int len)
int dm_i2c_write(struct udevice *dev, uint offset, const uint8_t *buffer, int len)

// 对上面接口的封装
int dm_i2c_reg_read(struct udevice *dev, uint offset)
int dm_i2c_reg_write(struct udevice *dev, uint offset, unsigned int val);
```

## 6 Display

### 6.1 框架支持

RK U-Boot 目前支持的显示接口包括：RGB、LVDS、EDP、MIPI 和 HDMI，未来还会加入 CVBS、DP 等。U-Boot 显示的 logo 图片来自 kernel 根目录下的 logo.bmp 和 logo_kernel.bmp，它们被打包在 resource.img 里。

对图片的要求:

- 8bit 或者 24bit BMP 格式；

- logo.bmp 和 logo_kernel.bmp 的图片分辨率大小一致；

- 对于 rk312x/px30/rk3308 这种基于 vop lite 结构的芯片，由于 VOP 不支持镜像，而 24bit 的 BMP 图片是按镜像存储，所以如果发现显示的图片做了 y 方向的镜像，请在 PC 端提前将图片做好 y 方向的镜像。

配置：

```
CONFIG_DM_VIDEO
CONFIG_DISPLAY
CONFIG_DRM_ROCKCHIP
CONFIG_DRM_ROCKCHIP_PANEL
CONFIG_DRM_ROCKCHIP_DW_MIPI_DSI
CONFIG_DRM_ROCKCHIP_DW_HDMI
CONFIG_DRM_ROCKCHIP_LVDS
CONFIG_DRM_ROCKCHIP_RGB
CONFIG_DRM_ROCKCHIP_RK618
CONFIG_ROCKCHIP_DRM_TVE
CONFIG_DRM_ROCKCHIP_ANALOGIX_DP
CONFIG_DRM_ROCKCHIP_INNO_VIDEO_COMBO_PHY
CONFIG_DRM_ROCKCHIP_INNO_VIDEO_PHY
```

框架代码：

```
drivers/video/drm/rockchip_display.c
drivers/video/drm/rockchip_display.h
```

驱动文件：

```
vop:
  drivers/video/drm/rockchip_crtc.c
  drivers/video/drm/rockchip_crtc.h
  drivers/video/drm/rockchip_vop.c
  drivers/video/drm/rockchip_vop.h
  drivers/video/drm/rockchip_vop_reg.c
  drivers/video/drm/rockchip_vop_reg.h

rgb:
  drivers/video/drm/rockchip_rgb.c
  drivers/video/drm/rockchip_rgb.h

lvds:
  drivers/video/drm/rockchip_lvds.c
  drivers/video/drm/rockchip_lvds.h

mipi:
  drivers/video/drm/rockchip_mipi_dsi.c
  drivers/video/drm/rockchip_mipi_dsi.h
  drivers/video/drm/rockchip-inno-mipi-dphy.c

edp:
  drivers/video/drm/rockchip_analogix_dp.c
  drivers/video/drm/rockchip_analogix_dp.h
  drivers/video/drm/rockchip_analogix_dp_reg.c
  drivers/video/drm/rockchip_analogix_dp_reg.h

hdmi:
  drivers/video/drm/dw_hdmi.c
  drivers/video/drm/dw_hdmi.h
  drivers/video/drm/rockchip_dw_hdmi.c
  drivers/video/drm/rockchip_dw_hdmi.h

panel:
  drivers/video/drm/rockchip_panel.c
  drivers/video/drm/rockchip_panel.h
```

### 6.2 相关接口

```c
// 显示 U-Boot logo 和 kernel logo：
void rockchip_show_logo(void);

// 显示 bmp 图片，目前主要用于充电图片显示：
void rockchip_show_bmp(const char *bmp);

// 将 U-Boot 中的一些变量通过 dtb 传给内核。
// 包括 kernel logo 的大小、地址、格式, crtc 输出扫描时序以及过扫描的配置。
// 未来还会加入 BCSH 等相关变量配置。
void rockchip_display_fixup(void *blob);
```

### 6.3 DTS 配置

```c
reserved-memory {
	#address-cells = <2>;
	#size-cells = <2>;
	ranges;

	drm_logo: drm-logo@00000000 {
		compatible = "rockchip,drm-logo";
		// 预留buffer用于kernel logo的存放，具体地址和大小在U-Boot中会修改
		reg = <0x0 0x0 0x0 0x0>;
	};
};

&route-edp {
    status = "okay";                      // 使能U-Boot logo显示功能
    logo,uboot = "logo.bmp";              // 指定U-Boot logo显示的图片
    logo,kernel = "logo_kernel.bmp";      // 指定kernel logo显示的图片
    logo,mode = "center";                 // center：居中显示，fullscreen：全屏显示
    charge_logo,mode = "center";          // center：居中显示，fullscreen：全屏显示
    connect = <&vopb_out_edp>;            // 确定显示通路，vopb->edp->panel
};

&edp {
    status = "okay"; // 使能edp
};

&vopb {
    status = "okay"; // 使能vopb
};

&panel {
    "simple-panel";
    ...
    status = "okay";

    disp_timings: display-timings {
        native-mode = <&timing0>;
        timing0: timing0 {
            ...
        };
    };
};
```

### 6.4 defconfig

目前除了 RK3308 之外的其他平台，U-Boot 的 defconfig 已经默认支持显示，只要在 dts 中将显示相关的信息配置好即可。RK3308 考虑到启动速度等一些原因默认不支持显示，需要在 defconfig 中加入如下修改：

```
--- a/configs/evb-rk3308_defconfig
+++ b/configs/evb-rk3308_defconfig
@@ -4,7 +4,6 @@ CONFIG_SYS_MALLOC_F_LEN=0x2000
CONFIG_ROCKCHIP_RK3308=y
CONFIG_ROCKCHIP_SPL_RESERVE_IRAM=0x0
CONFIG_RKIMG_BOOTLOADER=y
-# CONFIG_USING_KERNEL_DTB is not set
CONFIG_TARGET_EVB_RK3308=y
CONFIG_DEFAULT_DEVICE_TREE="rk3308-evb"
CONFIG_DEBUG_UART=y
@@ -55,6 +54,11 @@ CONFIG_USB_GADGET_DOWNLOAD=y
CONFIG_G_DNL_MANUFACTURER="Rockchip"
CONFIG_G_DNL_VENDOR_NUM=0x2207
CONFIG_G_DNL_PRODUCT_NUM=0x330d
+CONFIG_DM_VIDEO=y
+CONFIG_DISPLAY=y
+CONFIG_DRM_ROCKCHIP=y
+CONFIG_DRM_ROCKCHIP_RGB=y
+CONFIG_LCD=y
CONFIG_USE_TINY_PRINTF=y
CONFIG_SPL_TINY_MEMSET=y
CONFIG_ERRNO_STR=y
```

**关于 upstream defconfig 配置的说明：**

upstream 维护了一套 Rockchip U-Boot 显示驱动，目前主要支持 RK3288 和 RK3399 两个平台：

```
./drivers/video/rockchip/
```

如果要使用这套驱动，可以打开 CONFIG_VIDEO_ROCKCHIP，同时关闭 CONFIG_DRM_ROCKCHIP。跟我们目前 SDK 使用的显示驱动对比，后者的优势有：

- 支持的平台和显示接口更全面；

- HDMI、DP 等显示接口可以根据用户的设定输出指定分辨率，过扫描效果，显示效果调节效果等。

- U-Boot logo 可以平滑过渡到 kernel logo 直到系统起来；

### 6.5 LOGO分区

用户如果有动态更新开机LOGO的需求（一般在应用层发起更新），可以通过独立的LOGO分区实现。

操作步骤：

- 分区表中增加独立的LOGO分区

- 用户根据需要以某种方式动态更新LOGO分区中的图片。更新时，用户直接把原始图片更新到LOGO分区中即可，不需要任何打包。当LOGO分区的图片无效时，则仍旧使用resource文件中默认的图片。

**LOGO分区支持情况：**

如果代码只包含如下提交，则LOGO分区仅支持1张图片，只能替换默认的 logo.bmp：

  ```
  1d30bcc rockchip: resource: support parse "logo" partition picture
  ```

如果代码包含如下提交，LOGO分区支持2张图片：图片1用于替换logo.bmp，图片用于替换logo_kernel.bmp。两张图片紧挨着，图片之间保持512字节对齐，顺序不可更换。

  ```
  commit 07f987d8d495380787203e2bc2accd44100e6051
  Author: Joseph Chen <chenjh@rock-chips.com>
  Date:   Sun Dec 8 18:00:37 2019 +0800

      rockchip: resource: support parse logo_kernel.bmp from logo partition

      "logo" partition layout, not change order:

      |----------------------| 0x00
      | raw logo.bmp         |
      |----------------------| N*512-byte aligned
      | raw logo_kernel.bmp  |
      |----------------------|

      N: the sector count of logo.bmp

      Signed-off-by: Joseph Chen <chenjh@rock-chips.com>
      Change-Id: I2deba013d3963c99664c5bfd69693835a46ba48f
  ```

## 7 Pmic/Regulator

### 7.1 框架支持

PMIC/Regulator 驱动使用 pmic-uclass、regulator-uclass 框架和标准接口。

PMIC支持：

```
rk805/rk808/rk809/rk816/rk817/rk818
```

Regulator支持：

```
rk805/rk808/rk809/rk816/rk817/rk818/syr82x/tcs452x/fan53555/pwm/gpio/fixed
```

配置：

```c
CONFIG_DM_PMIC
CONFIG_PMIC_CHILDREN
CONFIG_PMIC_RK8XX        // 适用于目前所有RK8XX系列芯片
CONFIG_DM_REGULATOR
CONFIG_REGULATOR_PWM
CONFIG_REGULATOR_RK8XX   // 适用于目前所有RK8XX系列芯片
CONFIG_REGULATOR_FAN53555
```

框架代码：

```
./drivers/power/pmic/pmic-uclass.c
./drivers/power/regulator/regulator-uclass.c
```

驱动文件：

```
./drivers/power/pmic/rk8xx.c
./drivers/power/regulator/rk8xx.c
./drivers/power/regulator/fixed.c
./drivers/power/regulator/gpio-regulator.c
./drivers/power/regulator/pwm_regulator.c
./drivers/power/regulator/fan53555_regulator.c
```

### 7.2 相关接口

```c
// 获取regulator。 @platname：“regulator-name”指定的名字，如：vdd_arm、vdd_logic；
int regulator_get_by_platname(const char *platname, struct udevice **devp);

// 使能/关闭
int regulator_get_enable(struct udevice *dev);
int regulator_set_enable(struct udevice *dev, bool enable);
int regulator_set_suspend_enable(struct udevice *dev, bool enable);
int regulator_get_suspend_enable(struct udevice *dev);

// 配置/获取电压
int regulator_get_value(struct udevice *dev);
int regulator_set_value(struct udevice *dev, int uV);
int regulator_set_suspend_value(struct udevice *dev, int uV);
int regulator_get_suspend_value(struct udevice *dev);
```

### 7.3 init 电压

目前有两种方式为某路regulator设置初始化电压输出，前提是必须配置`regulator-boot-on`：

- 配置 `regulator-min-microvolt` 和 `regulator-min-microvolt` 为相同值；

- 配置 `regulator-init-microvolt = <...>`

```c
vdd_arm: DCDC_REG1 {
	regulator-name = "vdd_arm";
	regulator-boot-on；                     // 必须配置
	regulator-min-microvolt = <712500>;
	regulator-max-microvolt = <1450000>;
	regulator-init-microvolt = <1100000>;   // 设置初始化电压为1.1v
	......
};
```

### 7.4 跳过初始化

如果想跳过某路regulator的初始化，可增加`regulator-loader-ignore`。

```c
vdd_arm: DCDC_REG1 {
	regulator-name = "vdd_arm";
	regulator-loader-ignore;// 仅对U-Boot阶段的regulator初始化有效，kernel无效
	......
};
```

## 8 Charge

### 8.1 框架支持

U-Boot 原生代码不支持充电功能，RK自己实现了一套。

充电涉及的模块较多：Display、PMIC、电量计、充电动画、pwrkey、led、CPU低功耗休眠、Timer等。

电量计支持：

```
RK809/RK816/RK817/RK818/cw201x。
```

配置：

```c
// 框架
CONFIG_DM_CHARGE_DISPLAY
CONFIG_CHARGE_ANIMATION
CONFIG_DM_FUEL_GAUGE
// 驱动
CONFIG_POWER_FG_CW201X
CONFIG_POWER_FG_RK818
CONFIG_POWER_FG_RK817
CONFIG_POWER_FG_RK816
```

充电框架：

```
./drivers/power/charge-display-uclass.c
```

充电动画驱动：

```c
// 负责管理整个充电过程，它会获取电量、充电类型、按键事件，发起低功耗休眠等。
./drivers/power/charge_animation.c
```

电量计框架：

```
./drivers/power/fuel_gauge/fuel_gauge_uclass.c
```

电量计驱动：

```c
./drivers/power/fuel_gauge/fg_rk818.c
./drivers/power/fuel_gauge/fg_rk817.c	// rk809复用
./drivers/power/fuel_gauge/fg_rk816.c
......
```

逻辑流程：

```
charge-display-uclass.c
    => charge_animation.c
        => fuel_gauge_uclass.c
            => fg_rkxx.c
```

### 8.2 打包图片

充电图片位于`./tools/images/` 目录，需要打包进 resource.img 才能被充电框架显示。

内核编译得到的resource.img 默认没打包充电图片，需要在U-Boot 里另外单独打包。

```
$ ls tools/images/
battery_0.bmp  battery_1.bmp  battery_2.bmp  battery_3.bmp  battery_4.bmp  battery_bmp  battery_fail.bmp
```

打包命令：

```
./pack_resource.sh <input resource.img> 或
./scripts/pack_resource.sh <input resource.img>
```

打包信息：

```
./pack_resource.sh  /home/cjh/3399/kernel/resource.img

Pack ./tools/images/ & /home/guest/3399/kernel/resource.img to resource.img ...
Unpacking old image(/home/guest/3399/kernel/resource.img):
rk-kernel.dtb logo.bmp logo_kernel.bmp
Pack to resource.img successed!
Packed resources:
rk-kernel.dtb battery_1.bmp battery_2.bmp battery_3.bmp battery_4.bmp battery_bmp battery_fail.bmp logo.bmp logo_kernel.bmp battery_0.bmp

resource.img is packed ready
```

成功后会在 U-Boot 根目录下生成包含图片的 resource.img，通过 hd 命令确认内容：

```c
hd resource.img | less

00000000  52 53 43 45 00 00 00 00  01 01 01 00 0a 00 00 00  |RSCE............|
00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
......
*
00000400  45 4e 54 52 62 61 74 74  65 72 79 5f 31 2e 62 6d  |ENTRbattery_1.bm| // 图片1
00000410  70 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |p...............|
00000420  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00000500  00 00 00 00 4d 00 00 00  9c 18 00 00 00 00 00 00  |....M...........|
00000510  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00000600  45 4e 54 52 62 61 74 74  65 72 79 5f 32 2e 62 6d  |ENTRbattery_2.bm| // 图片2
00000610  70 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |p...............|
00000620  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
......
```

### 8.3 DTS 配置

DTS充电节点：

```c
charge-animation {
	compatible = "rockchip,uboot-charge";
	status = "okay";

	rockchip,uboot-charge-on = <0>;             // 是否开启U-Boot充电
	rockchip,android-charge-on = <1>;           // 是否开启Android充电

	rockchip,uboot-exit-charge-level = <5>;     // U-Boot充电时，允许开机的最低电量
	rockchip,uboot-exit-charge-voltage = <3650>;// U-Boot充电时，允许开机的最低电压
	rockchip,screen-on-voltage = <3400>;        // U-Boot充电时，允许点亮屏幕的最低电压

	rockchip,uboot-low-power-voltage = <3350>;  // U-Boot无条件强制进入充电模式的最低电压

	rockchip,system-suspend = <1>;              // 是否灭屏时进入trust低功耗待机（要ATF支持）
	rockchip,auto-off-screen-interval = <20>;   // 自动灭屏超时，单位秒，默认15s
	rockchip,auto-wakeup-interval = <10>;       // 休眠自动唤醒时间，单位秒。如果值为0或没
	                                            // 有这个属性，则禁止休眠自动唤醒，一般用于
	                                            // 压力测试使用
	rockchip,auto-wakeup-screen-invert = <1>;   // 休眠自动唤醒时是否需要亮/灭屏
};
```

### 8.4 系统休眠

Pwrkey按键：

- 短按 pwrkey 可以亮/灭屏，灭屏时系统会进入低功耗模式；

- 长按 pwrkey 可开机进入系统

低功模式有2种，通过 `rockchip,system-suspend = <VAL>` 选择：

- VAL为0：cpu wfi 模式。此时不处理外设，仅仅cpu 进入低功耗模式；
- VAL为1：system suspend 模式，需要ATF 支持才有效。类同kernel的系统深度待机，整个SoC进入待机。

ATF支持低功耗的版本要求：

|  芯片  |                       最低版本                       |
| :----: | :--------------------------------------------------: |
| RK3399 |                rk3399_bl31_v1.32.elf                 |
| RK3368 |                rk3368h_bl31_v2.22.elf                |
|  PX30  |                 px30_bl31_v1.05.elf                  |
| RK3326 |                rk3326_bl31_v1.05.elf                 |
| RK3308 | rk3308_bl31_v2.00.elf、rk3308_bl31_aarch32_v2.20.elf |
| RK312X |               rk3126_tee_ta_v1.39.bin                |
| RK3288 |               rk3288_tee_ta_v1.43.bin                |

### 8.5 更换图片

1. 更换`./tools/images/`目录下的图片（采用 8bit 或 24bit bmp），使用命令`ls | sort`确认图片排列顺序是低电量到高电量，使用 pack_resource.sh 脚本把图片打包进 resource.img；
2. 修改`./drivers/power/charge_animation.c` 里的图片和电量关系；

```c
/*
 * IF you want to use your own charge images, please:
 *
 * 1. Update the following 'image[]' to point to your own images;
 * 2. You must set the failed image as last one and soc = -1 !!!
 */
static const struct charge_image image[] = {
	{ .name = "battery_0.bmp", .soc = 5, .period = 600 },
	{ .name = "battery_1.bmp", .soc = 20, .period = 600 },
	{ .name = "battery_2.bmp", .soc = 40, .period = 600 },
	{ .name = "battery_3.bmp", .soc = 60, .period = 600 },
	{ .name = "battery_4.bmp", .soc = 80, .period = 600 },
	{ .name = "battery_bmp", .soc = 100, .period = 600 },
	{ .name = "battery_fail.bmp", .soc = -1, .period = 1000 },
};

// @name：图片的名字；
// @soc：图片对应的电量；
// @period：图片刷新时间（单位：ms）；
// 注意：最后一张图片必须是 fail 图片，且“soc=-1”不可改变 !!
```

### 8.4 充电灯

实际产品中用户对 led 的控制需求各不相同，因此充电框架仅支持 2 个灯。充电时刻 led、充满时刻 led：

- 充满时刻 led：充电时候，电量有变化的时候，才会翻转 led 显示；
- 充满时刻 led：电量 100%充满时，才会点亮 led 灯；

上述2个Led 仅是一个demo，用户请根据自己的需求修改代码。

配置选项：

```
CONFIG_LED_CHARGING_NAME
CONFIG_LED_CHARGING_FULL_NAME
```

这两个配置选项用于指定 led 的 label 属性，请参考Led章节。

## 9 Storage

存储驱动使用标准的存储框架，访问接口对接到 BLK 层用于支持文件系统。目前支持的存储设备：eMMC、Nand flash、SPI Nand flash、SPI Nor flash。

### 9.1 框架支持

**rknand**

rknand 是针对大容量 Nand flash 设备所设计的存储驱动，通过 Nandc host 与 Nand flash device 通信，具体适用颗粒选型参考《RKNandFlashSupportList》，适用以下颗粒：

- SLC、MLC、TLC Nand flash

配置：

```
CONFIG_RKNAND
```

驱动文件：

```c
./drivers/rknand/
```

**rkflash**

rkflash 是针对选用小容量存储的设备所设计的存储驱动，其中 Nand flash 的支持是通过 Nandc host 与 Nand flash device 通信完成，SPI flash 的支持是通过 SFC host 与 SPI flash devices 通信完成，具体适用颗粒选型参考《RK SpiNor and  SLC Nand SupportList》，适用以下颗粒：

- 128MB、256MB 和 512MB 的 SLC Nand flash
- 部分 SPI Nand flash
- 部分 SPI Nor flash 颗粒

配置：

```c
CONFIG_RKFLASH

CONFIG_RKNANDC_NAND  /* 小容量并口Nand flash */
CONFIG_RKSFC_NOR     /* SPI Nor flash */
CONFIG_RKSFC_NAND    /* SPI Nand flash */
```

驱动文件：

```c
./drivers/rkflash/
```

注意：

1. SFC（serial flash controller）是 Rockchip 为简便支持 spi flash 所设计的专用模块；
2. 由于 rknand 驱动与 rkflash 驱动 Nand 代码中 ftl 部分不兼容，所以

- CONFIG_RKNAND 与 CONFIG_RKNANDC_NAND 不能同时配置
- CONFIG_RKNAND 与 CONFIG_RKSFC_NAND 不能同时配置

**MMC & SD**

MMC为多媒体卡，比如 eMMC；SD为是一种基于半导体快闪记忆器的新一代记忆设备。在rockchip平台，它们共用一个 dw_mmc 控制器（除了rk3399，rk3399pro）。

配置：

```
CONFIG_MMC_DW=y
CONFIG_MMC_DW_ROCKCHIP=y
CONFIG_CMD_MMC=y
```

驱动文件：

```
./drivers/mmc/
```

### 9.2 相关接口

存储驱动的访问接口都对挂到BLK层，所以无论何种存储都通过如下接口访问：

```c
// 获取存储句柄
struct blk_desc *rockchip_get_bootdev(void)

// 访问接口
unsigned long blk_dread(struct blk_desc *block_dev, lbaint_t start,
                        lbaint_t blkcnt, void *buffer)
unsigned long blk_dwrite(struct blk_desc *block_dev, lbaint_t start,
                         lbaint_t blkcnt, const void *buffer)
unsigned long blk_derase(struct blk_desc *block_dev, lbaint_t start,
                         lbaint_t blkcnt)
```

### 9.3 DTS 配置

eMMC配置：

```c
// rkxxxx.dtsi配置
emmc: dwmmc@ff390000 {
	compatible = "rockchip,px30-dw-mshc", "rockchip,rk3288-dw-mshc";
	reg = <0x0 0xff390000 0x0 0x4000>;      // 控制器寄存器base address及长度
	max-frequency = <150000000>;            // eMMC普通模式时钟为50MHz,当配置为eMMC
                                            // HS200模式，该max-frequency生效
	clocks = <&cru HCLK_EMMC>, <&cru SCLK_EMMC>,
		 <&cru SCLK_EMMC_DRV>, <&cru SCLK_EMMC_SAMPLE>;   // 控制器对应时钟编号
	clock-names = "biu", "ciu", "ciu-drv", "ciu-sample";  // 控制器时钟名
	fifo-depth = <0x100>;                                 // fifo深度，默认配置
	interrupts = <GIC_SPI 53 IRQ_TYPE_LEVEL_HIGH>;        // 中断配置
	status = "disabled";
};

// rkxxxx-u-boot.dtsi
&emmc {
	u-boot,dm-pre-reloc;
	status = "okay";
}

// rkxxxx.dts
&emmc {
	bus-width = <8>;                   // 设备总线位宽
	cap-mmc-highspeed;                 // 标识此卡槽支持highspeed mmc
	mmc-hs200-1_8v;                    // 支持HS200
	supports-emmc;                     // 标识此插槽为eMMC功能，必须添加，否则无法初始化外设
	disable-wp;                        // 对于无物理WP管脚，需要配置
	non-removable;                     // 此项表示该插槽为不可移动设备。 此项为必须添加项
	num-slots = <1>;                   // 标识为第几插槽
	status = "okay";
};
```

Nandc 配置：

```
&nandc {
	 u-boot,dm-pre-reloc;
	status = "okay";
};
```

SFC 配置：

```
&sfc {
	u-boot,dm-pre-reloc;
	status = "okay";
};
```

## 10 Uart

serial 使用 serial-uclass.c 框架和标准接口，目前主要是UART debug在使用。

配置：

```c
// 使能配置
CONFIG_DEBUG_UART
CONFIG_SYS_NS16550

// 参数配置
CONFIG_DEBUG_UART_BASE
CONFIG_DEBUG_UART_CLOCK
CONFIG_BAUDRATE
```

框架代码：

```
./drivers/serial/serial-uclass.c
```

驱动代码：

```c
./drivers/serial/ns16550.c
```

### 10.1 单独更换

单独更换 U-Boot 阶段的UART debug 流程如下（uart2 为例）：

- `CONFIG_ROCKCHIP_PRELOADER_SERIAL` 禁用；

- `board_debug_uart_init()` 里配置 uart iomux（注意：某些平台有m0、m1...模式要配置 ）；

- `board_debug_uart_init()` 里配置 uart clock ，保证时钟源是 24Mhz；

- defconfig 更新`CONFIG_BAUDRATE` ；

- defconfig 更新`CONFIG_DEBUG_UART_BASE`；

- U-Boot uart 节点中增加 2 个必要属性并且使能：

  ```
  &uart2 {
		u-boot,dm-pre-reloc;
		clock-frequency = <24000000>;
		status = "okay";
  };
  ```

- U-Boot chosen 节点中指定 stdout-path：

  ```
  chosen {
		stdout-path = &uart2;
  };
  ```

### 10.2 全局更换

Pre-loader serial 是实现前级固件共享UART debug 配置的机制，这些固件包括：ddr、miniloader、bl31、op-tee、U-Boot。原理：由最早阶段的 ddr bin 配置好UART debug 并且通过 ATAGS 传参机制逐级传递下去，各级固件获取 UART debug 配置进行使用（不包括 kernel）。

用户可以通过修改 ddr bin里的串口配置实现UART debug的全局替换，步骤：

**DDR bin 配置**

rkbin 仓库里提供了工具给用户配置不同的参数，包括串口更换：

```
tools/ddrbin_tool
tools/ddrbin_param.txt
tools/ddrbin_tool_user_guide.txt
```

**U-Boot 配置**

1 使能配置：

```c
CONFIG_ROCKCHIP_PRELOADER_SERIAL  // 已经默认使能
```

2 rkxx-u-boot.dtsi 中把使用到的 uart 节点加上属性“u-boot,dm-pre-reloc;”；

3 aliases 建立 serial 别名，因为U-Boot是通过aliaes找到目标节点并初始化它的。

例如：./arch/arm/dts/rk1808-u-boot.dtsi 里为了方便，为所有 uart 都建立别名；

```c
aliases {
	mmc0 = &emmc;
	mmc1 = &sdmmc;

// 必须创建别名
	serial0 = &uart0;
	serial1 = &uart1;
	serial2 = &uart2;
	serial3 = &uart3;
	serial4 = &uart4;
	serial5 = &uart5;
	serial6 = &uart6;
	serial7 = &uart7;
};

.....

// 必须增加u-boot,dm-pre-reloc属性
&uart0 {
	u-boot,dm-pre-reloc;
};
&uart1 {
	u-boot,dm-pre-reloc;
};
&uart2 {
	u-boot,dm-pre-reloc;
	clock-frequency = <24000000>;
	status = "okay";
};
&uart3 {
	u-boot,dm-pre-reloc;
};
&uart4 {
	u-boot,dm-pre-reloc;
};
```

### 10.3 关闭打印

```
CONFIG_DISABLE_CONSOLE=y
```

### 10.4 相关接口

```c
// UART debug接口
void putc(const char c);
void puts(const char *s);
int printf(const char *fmt, ...);
void flushc(void);

// 跟外设通信功能的普通UART接口
int serial_dev_getc(struct udevice *dev);
int serial_dev_tstc(struct udevice *dev);
void serial_dev_putc(struct udevice *dev, char ch);
void serial_dev_puts(struct udevice *dev, const char *str);
void serial_dev_setbrg(struct udevice *dev, int baudrate);
void serial_dev_clear(struct udevice *dev);
```

## 11 Key

### 11.1 框架支持

U-Boot 框架默认没有支持按键功能，RK 自己实现了一套按键框架。

实现规则：

- 所有按键都通过 kernel 和 U-Boot 的 DTS 指定，U-Boot 不使用 hard code 的方式定义任何按键；
- U-Boot 优先查找 kernel dts 中的按键，找不到再查找 U-Boot dts 中的按键。
- U-Boot dts里仅定义了烧写按键。
- 如果用户要更新烧写按键定义，请同时更新kernel和U-Boot的dts。

配置：

```
CONFIG_DM_KEY
CONFIG_RK8XX_PWRKEY
CONFIG_ADC_KEY
CONFIG_GPIO_KEY
CONFIG_RK_KEY
```

框架代码：

```
./include/dt-bindings/input/linux-event-codes.h
./drivers/input/key-uclass.c
./include/key.h
```

驱动代码：

```c
./drivers/input/rk8xx_pwrkey.c    // 支持PMIC的pwrkey(RK805/RK809/RK816/RK817)
./drivers/input/rk_key.c          // 支持compatible = "rockchip,key"
./drivers/input/gpio_key.c        // 支持compatible = "gpio-keys"
./drivers/input/adc_key.c         // 支持compatible = "adc-keys"
```

pwrkey 仅以中断方式被识别，其余 gpio 按键以轮询方式被识别。

### 11.2 相关接口

接口：

```
int key_read(int code)
```

code 定义：

```
/include/dt-bindings/input/linux-event-codes.h
```

返回值：

```c
enum key_state {
	KEY_PRESS_NONE,      // 非完整的短按（没有释放按键）或非完整长按（按下时间不够长）；
	KEY_PRESS_DOWN,      // 一次完整的短按（按下=>释放）；
	KEY_PRESS_LONG_DOWN, // 一次完整的长按（可以不释放）；
	KEY_NOT_EXIST,       // 按键不存在
};
```

KEY_PRESS_LONG_DOWN 默认时长 2000ms，目前只用于 U-Boot 充电的 pwrkey 长按事件。

```
#define KEY_LONG_DOWN_MS	2000
```

范例：

```c
int ret;

ret = key_read(KEY_VOLUMEUP);
...
```

## 12 Vendor Storage

Vendor Storage 用于存放 SN、MAC 等不需要加密的小数据。数据存放在 NVM（eMMC、NAND 等）的保留分区中，有多个备份，更新数据时数据不丢失，可靠性高。

详细的资料参考文档《appnote rk vendor storage》。

### 12.1 原理概述

一共把 vendor 的存储块分成 4 个分区，vendor0、vendor1、vendor2、vendor3。每个 vendorX（X=0、1、2、3）的 hdr 里都有一个单调递增的 version 字段用于表明 vendorX 被更新的时刻点。每次读操作只读取最新的 vendorX（即 version 最大），写操作的时候会更新 version 并且把整个原有信息和新增信息搬移到 vendorX+1 分区里。例如当前从 vendor2 读取到信息，经过修改后再回写，此时写入的是 vendor3。这样做只是为了起到一个简单的安全防护作用。

### 12.2 框架支持

U-Boot 框架没有支持 Vendor Storage 功能，Rockchip 自己实现了一套 Vendor Storage 驱动。

配置：

```
CONFIG_ROCKCHIP_VENDOR_PARTITION
```

驱动文件：

```
./arch/arm/mach-rockchip/vendor.c
./arch/arm/include/asm/arch-rockchip/vendor.h
```

### 12.3 相关接口

```c
int vendor_storage_read(u16 id, void *pbuf, u16 size)
int vendor_storage_write(u16 id, void *pbuf, u16 size)
```

关于 id 的定义和使用，请参考《appnote rk vendor storage》。

### 12.4 功能自测

U-Boot 串口命令行下使用"rktest vendor"命令可以进行 Vendor Storage 功能自测。

## 13 OPTEE Client

U-Boot在ARM TrustZone里属于Non-Secure World，需要借助OPTEE Client才能访问安全资源。

### 13.1 框架支持

U-Boot 框架默认没有支持OPTEE Client功能，RK 自己实现了一套。

配置：

```c
// 总使能
CONFIG_OPTEE_CLIENT

// 旧平台使用，如 RK312x、RK322x、RK3288、RK3228H、RK3368、RK3399
CONFIG_OPTEE_V1
// 新平台使用，如 RK3326、RK3308
CONFIG_OPTEE_V2
// 当 eMMC 的 RPMB 不能用时必须开启此配置，即启用security分区！
CONFIG_OPTEE_ALWAYS_USE_SECURITY_PARTITION
```

框架和驱动：

```
lib/optee_clientApi/
```

### 13.2 固件说明

使用的 trust.img 必须启用 TA 功能，否则无法跟OPTEE Client交互。

### 13.3 接口文档

Optee client 驱动在 lib/optee_client 目录下，Optee Client Api 请参考《TEE_Client_API_Specification-V1.0_c.pdf》。
下载地址为：<https://globalplatform.org/specs-library/tee-client-api-specification/>

### 13.4 共享内存

U-Boot 与 Optee 通信时的数据需放在共享内存中。用户可通过 `TEEC_AllocateSharedMemory()` 申请共享内存，但建议不超过 1M。若超过则建议分割数据进行多次传递，使用完需调用 `TEEC_ReleaseSharedMemory()` 释放共享内存。

### 13.5 测试命令

作用：测试安全存储功能。U-Boot 命令行：

```
=> mmc testsecurestorage
```

该测试用例将循环测试安全存储读写功能，当硬件使用 emmc 时将测试 rpmb 与 security 分区两种安全存储方式；当硬件使用 nand 时只测试 security 分区安全存储。

### 13.6 常见错误打印

- 没有找到 emmc 或者 nand 设备。此时请检查 U-Boot 是否缺少配置，或者硬件是否损坏。

  ```
  "TEEC: Could not find device"
  ```

- 没有找到 security 分区。当没有RPMB可用时，需要在 parameter.txt 中定义 security 分区。

  ```
  "TEEC: Could not find security partition"
  ```

- 第一次使用 security 分区进行安全存储或 security 分区数据被非法篡改时会出现该打印。

  ```
  "TEEC: verify [%d] fail, cleanning ...."
  ```

- 安全存储的空间不足。请检查存储的数据是否过大，或者之前存储过大量的数据但没有删除。

  ```
  "TEEC: Not enough space available in secure storage !"
  ```

## 14 DVFS

本章节的DVFS不同于kernel，是专门针对宽温芯片的动态调频调压机制。

### 14.1 宽温策略

U-Boot 框架没有支持 DVFS，为了支持某些芯片的宽温功能，RK 实现了一套 DVFS 宽温驱动根据芯片温度调整 cpu/dmc 频率-电压。但有别于内核 DVFS 驱动，这套宽温驱动仅仅在触发最高/低温度阈值时进行控制。

**宽温策略：**

1. 宽温驱动用于调整 cpu/dmc 的频率-电压，控制策略可同时对 cpu 和 dmc 生效，也可只对其中一个生效，由 dts 配置决定；cpu 和 dmc 的控制策略是一样的；
2. 宽温驱动会解析 cpu/dmc 节点的 opp table、regulator、clock、thermal zone 的"trip-point-0"，获取频率-电压档位、最高/低温度阈值、允许的最高电压等信息；
3. 若 cpu/dmc 的 opp table 里指定了 rockchip,low-temp = <...>或 rockchip,high-temp = <...>，又或者 cpu/dmc 引用了 thermal zone 的 trip 节点，那么 cpu/dmc 宽温控制策略就会生效；
4. 关键属性：

- rockchip,low-temp：最低温度阈值，下述用 TEMP_min 表示；
- rockchip,high-temp 和 thermal zone：最高温度阈值，下述用 TEMP_max 表示（如果二者都有效，策略上都会拿当前温度进与之比较）；
- rockchip,max-volt：允许设置的最高电压值，下述用 V_max 表示；

5. 阈值触发的处理：

- 如果温度高于 TEMP_max，把频率和电压都降到最低档位；
- 如果温度低于 TEMP_min，默认抬压 50mv。若抬压 50mv 会导致电压超过 V_max，则电压设定为 V_max，同时把频率降低 2 档；

6. 目前宽温策略应用在 2 个时刻点：

- regulator 和 clk 框架初始化完成后，宽温驱动进行初始化并且执行一次宽温策略，具体位置在 board.c 文件的 board_init()中调用；
- preboot 阶段（即加载固件之前）再执行一次宽温策略：如果 dts 节点中指定了"repeat"等相关属性（见下文），当执行完本次宽温策略后芯片温度依然不在温度阈值范围内，那就停止系统启动并且不断执行宽温策略，直到芯片温度回归到阈值范围内才继续启动系统。如果没有"repeat"等相关属性，则执行完本次宽温策略后就直接启动系统，目前一般不需要 repeat 属性。

### 14.2 框架支持

框架代码：

```
./drivers/power/dvfs/dvfs-uclass.c
./include/dvfs.h
./cmd/dvfs.c
```

驱动代码：

```
./drivers/power/dvfs/rockchip_wtemp_dvfs.c
```

### 14.3 相关接口

```c
// 执行一次dvfs策略
int dvfs_apply(struct udevice *dev);

// 如果存在repeat属性，当温度不在阈值范围内时循环执行dvfs策略
int dvfs_repeat_apply(struct udevice *dev);
```

### 14.4 启用宽温

1. 配置使能：

```
CONFIG_DM_DVFS=y
CONFIG_ROCKCHIP_WTEMP_DVFS=y

CONFIG_DM_THERMAL=y
CONFIG_ROCKCHIP_THERMAL=y
CONFIG_USING_KERNEL_DTB=y
```

2. 指定 CONFIG_PREBOOT：

```
#ifdef CONFIG_DM_DVFS
#define CONFIG_PREBOOT	"dvfs repeat"
#else
#define CONFIG_PREBOOT
#endif
```

3. kernel dts 配置宽温节点

```c
uboot-wide-temperature {
	compatible = "rockchip,uboot-wide-temperature";

	// 可选项。表示是否在U-Boot阶段触发cpu的最高/低温度阈值时让宽温驱动停止启动系统，
	// 且不断执行宽温处理策略，直到芯片温度回归到阈值范围内才继续启动系统。
	cpu,low-temp-repeat;
	cpu,high-temp-repeat;

	// 可选项。表示是否在U-Boot阶段触发dmc的最高/低温度阈值时让宽温驱动停止启动系统，
	// 且不断执行宽温处理策略，直到芯片温度回归到阈值范围内才继续启动系统。
	dmc,low-temp-repeat;
	dmc,high-temp-repeat;

	status = "okay";
};
```

   一般情况下不需要配置上述的 repeat 相关属性。

### 14.5 宽温结果

当 cpu 温控启用时有如下打印：

```c
// <NULL>表明没有指定低温阈值
DVFS: cpu: low=<NULL>'c, high=95'c, Vmax=1350000uV, tz_temp=88.0'c, h_repeat=0, l_repeat=0
```

当 cpu 温控触发高温阈值时会有调整信息：

```
DVFS: 90.352'c
DVFS: cpu(high): 600000000->408000000 Hz, 1050000->950000 uV
```

当 cpu 温控触发低温阈值时会有调整信息：

```
DVFS: 10.352'c
DVFS: cpu(low): 600000000->600000000 Hz, 1050000->1100000 uV
```

同理，当 dmc 触发高低温阈值时，也会有上述信息打印，信息前缀为"dmc"：

```
DVFS: dmc: ......
DVFS: dmc(high): ......
DVFS: dmc(low): ......
```

## 15 AMP

### 15.1 框架支持

U-Boot 框架默认没有 AMP(Asymmetric Multi-Processing) 支持，RK 自己实现了一套 AMP 框架和驱动，即不同的CPU运行不同的固件。
配置：

```
CONFIG_AMP
CONFIG_ROCKCHIP_AMP
```

框架代码：

```
./drivers/cpu/amp-uclass.c
./drivers/cpu/rockchip_amp.c
```

固件打包工具：

```
./scripts/mkkrnlimg
```

### 15.2 相关接口

```c
// bring-up所有amp核
int amp_cpus_on(void);
// bring-up某个amp核；@cpu 是mpidr值，详见下文描述。
int amp_cpu_on(u32 cpu);
```

### 15.3 功能启用

1. kernel DTS 增加/amps 节点：

```c
amps {
	compatible = "uboot,rockchip-amp";
	status = "okay";

	amp@0 {
			description  = "mcu-os0";          // amp@0的firmware名字
			partition    = "mcu0";             // amp@0的firmware分区名
			cpu          = <0x101>;            // amp@0上运行的cpu（mpidr）
			load         = <0x800000>;         // amp@0的firmware内存加载地址
			entry        = <0x800000>;         // amp@0的firmware内存入口地址
			memory       = <0x800000 0x400000>;// amp@0的内存空间范围，kernel不可见
	};

	amp@1 {
			......
	};

	......
};
```

特别说明：

- 通常情况下，load 和 entry 是相同地址，但是不排除用户有特殊情况，可根据实际设置；

- cpu：这里不是填写 0、1、2、3...，而是 cpu 的 mpdir(Multiprocessor Affinity Register)，它是每个 cpu 独有的硬件 ID。在/cpus 节点下，各个 cpu 节点会通过```reg = <...>```属性指明。

  例如：32 位某 cpuX 为：reg = <0x101>，64 位的某 cpuX 为：reg = <0x0 0x101>（64 位平台取低地址 0x101 即可）。

- memory：U-Boot 会告知 kernel 这段内存不可见；

- 已经作为 AMP 使用的 core，需要把/cpus 节点下对应的 cpu 节点删除；

   上述amps节点也可以定义在 U-Boot  dts，请记得增加属性```u-boot,dm-pre-reloc```；

2. 固件打包：

   使用./scripts/mkkrnlimg 工具对 bin 打包，例如：打包 mcu0.bin 生成 mcu0.img

   ```
   ./scripts/mkkrnlimg mcu0.bin mcu0.img
   ```

3. 分区表增加分区

   在 parameter.txt 分区表文件中增加相应的 amp 固件分区，例如：增加"mcu0"分区；

4. bring up

   U-Boot 框架会自动发起所有 AMP 的 bring up，可以看到打印：

   ```c
   Brought up cpu[101] on mcu-os0 entry 0x0800000 ...OK // 如果失败，会有failed信息
   ```

## 16 IO-Domain

### 16.1 框架支持

U-Boot 框架默认没有对 io-domain 的支持，RK 自己实现了一套。

配置：

```
CONFIG_IO_DOMAIN
CONFIG_ROCKCHIP_IO_DOMAIN
```

框架代码：

```
./drivers/power/io-domain/io-domain-uclass.c
```

驱动代码：

```
./drivers/power/io-domain/rockchip-io-domain.c
```

### 16.2 相关接口

```
void io_domain_init(void)
```

用户不需要主动调用```io_domain_init()```，只需要开启上述配置即可，U-Boot框架会自动初始化。

## 17 Watchdog

### 17.1 框架支持

watchdog 驱动使用 wdt-uclass.c 框架和标准接口。

配置：

```
CONFIG_WDT
CONFIG_ROCKCHIP_WATCHDOG
```

框架代码：

```
./drivers/watchdog/wdt-uclass.c
```

驱动代码：

```
./drivers/watchdog/rockchip_wdt.c
```

### 17.2 相关接口

```c
// 设置喂狗超时时间且启动wdt（@flags默认填0）
int wdt_start(struct udevice *dev, u64 timeout_ms, ulong flags);
// 关闭wdt
int wdt_stop(struct udevice *dev);
// 喂狗
int wdt_reset(struct udevice *dev);
// 忽略，目前未做底层驱动实现
int wdt_expire_now(struct udevice *dev, ulong flags)
```

目前 U-Boot 的默认流程里不启用、也不使用 wdt 功能，用户可根据自己的产品需求进行启用。

## 18 Crypto

Crypto 模块主要用于实现硬件级别的加密和哈希算法，目前有两个IP版本：

- Crypto V1：rk3399/rk3368/rk3328/rk3229/rk3288/rk3128；
- Crypto V2：rk3326/px30/rk3308/rk1808；

### 18.1 框架支持

U-Boot 默认没有crypto框架支持，RK 自己实现了一套。

配置：

```
CONFIG_DM_CRYPTO
CONFIG_ROCKCHIP_CRYPTO_V1
CONFIG_ROCKCHIP_CRYPTO_V2
```

框架代码：

```
./drivers/crypto/crypto-uclass.c
./cmd/crypto.c
```

驱动代码：

```c
// crypto v1:
./drivers/crypto/rockchip/crypto_v1.c

// crytpo v2:
./drivers/crypto/rockchip/crypto_v2.c
./drivers/crypto/rockchip/crypto_v2_pka.c
./drivers/crypto/rockchip/crypto_v2_util.c
```

### 18.2 相关接口

```c
// 获取crypto：
struct udevice *crypto_get_device(u32 capability);
// SHA接口：
int crypto_sha_init(struct udevice *dev, sha_context *ctx);
int crypto_sha_update(struct udevice *dev, u32 *input, u32 len);
int crypto_sha_final(struct udevice *dev, sha_context *ctx, u8 *output);
int crypto_sha_csum(struct udevice *dev, sha_context *ctx,
		    char *input, u32 input_len, u8 *output);
// RSA接口：
int crypto_rsa_verify(struct udevice *dev, rsa_key *ctx, u8 *sign, u8 *output);
```

- 接口使用请参考：```./cmd/crypto.c```；
- v1 和 v2 的 SHA 使用不同：v1 要求 crypto_sha_init() 时必须先把要计算的数据总长度赋给 `ctx->length`，v2 不需要；

### 18.3 DTS 配置

crypto 节点必须定义在 U-Boot dts ，主要原因：

- 各平台旧 SDK 的内核 dts 没有 crypto 节点，因此需要考虑对旧 SDK 的兼容；
- U-Boot 的 secure boot 会用到 crypto，因此由 U-Boot 自己控制 crypto 更为安全合理；

1. crypto v1 配置（RK3399 为例）：

```c
crypto: crypto@ff8b0000 {
	u-boot,dm-pre-reloc;

	compatible = "rockchip,rk3399-crypto";
	reg = <0x0 0xff8b0000 0x0 0x10000>;
	clock-names = "sclk_crypto0", "sclk_crypto1";
	clocks = <&cru SCLK_CRYPTO0>, <&cru SCLK_CRYPTO1>; // 不需要指定频率，默认100M
	status = "disabled";
};
```

2. crypto v2 配置（px30 为例）：

```c
crypto: crypto@ff0b0000 {
	u-boot,dm-pre-reloc;

	compatible = "rockchip,px30-crypto";
	reg = <0x0 0xff0b0000 0x0 0x4000>;
	clock-names = "sclk_crypto", "apkclk_crypto";
	clocks = <&cru SCLK_CRYPTO>, <&cru SCLK_CRYPTO_APK>;
	clock-frequency = <200000000>, <300000000>; // 一般需要指定频率
	status = "disabled";
};
```

- crypto v1 和 v2 的 dts 配置差异在于 clk 频率指定。

## 19 Reset

### 19.1 框架支持

reset 驱动使用 reset-uclass.c 框架和标准接口。RK 平台上reset 的实质是进行 CRU 软复位。

配置：

```
CONFIG_DM_RESET
CONFIG_RESET_ROCKCHIP
```

框架代码：

```
./drivers/reset/reset-uclass.c
```

驱动代码：

```
./drivers/reset/reset-rockchip.c
```

### 19.2 相关接口

```c
// 获取reset句柄
int reset_get_by_index(struct udevice *dev, int index, struct reset_ctl *reset_ctl);
int reset_get_by_name(struct udevice *dev, const char *name,
                      struct reset_ctl *reset_ctl);
// 释放reset
int reset_free(struct reset_ctl *reset_ctl);
// 请求reset
int reset_request(struct reset_ctl *reset_ctl);
// 触发reset、释放reset
int reset_assert(struct reset_ctl *reset_ctl);
int reset_deassert(struct reset_ctl *reset_ctl);
```

范例：

```c
struct reset_ctl reset_ctl;

ret = reset_get_by_name(dev, "mac-phy", &reset_ctl);
if (ret) {
	debug("reset_get_by_name() failed: %d\n", ret);
	return ret;
}

ret = reset_request(&reset_ctl);
if (ret)
	return ret;

ret = reset_assert(&reset_ctl);
if (ret)
	return ret;

......

ret = reset_deassert(&reset_ctl);
if (ret)
	return ret;

......

ret = reset_free(&reset_ctl);
if (ret)
	return ret;
```

### 19.3 DTS 配置

U-Boot 默认启用reset功能，用户只需在外设节点里指定要操作的 reset 对象即可：

```c
// 格式：
reset-names = <name-string-list>
resets = <cru-phandle-list>
```

例如 gmac2phy：

```c
gmac2phy: ethernet@ff550000 {
	compatible = "rockchip,rk3328-gmac";
	......

	// 指定reset属性
	reset-names = "stmmaceth", "mac-phy";
	resets = <&cru SRST_GMAC2PHY_A>, <&cru SRST_MACPHY>;
};
```

## 20 Led

### 20.1 框架支持

Led 驱动使用 led-uclass.c 框架和标准接口。

配置：

```
CONFIG_LED_GPIO
```

框架代码：

```c
drivers/led/led-uclass // 默认编译
```

驱动代码：

```c
drivers/led/led_gpio.c // 支持 compatible = "gpio-leds"
```

### 20.2 相关接口

```c
// 获取led device
int led_get_by_label(const char *label, struct udevice **devp);
// 设置/获取led状态
int led_set_state(struct udevice *dev, enum led_state_t state);
enum led_state_t led_get_state(struct udevice *dev);
// 忽略，目前未做底层驱动实现
int led_set_period(struct udevice *dev, int period_ms);
```

### 20.3 DTS 节点

U-Boot 的 led_gpio.c 功能相对简单，只解析 led 节点下的 3 个属性：

- gpios：led 控制引脚和有效状态；
- label：led 名字；
- default-state：默认状态，驱动 probe 时会被设置；

```c
leds {
	compatible = "gpio-leds";
	status = "okay";

	blue-led {
		gpios = <&gpio2 RK_PA1 GPIO_ACTIVE_LOW>;
		label = "battery_full";
		default-state = "off";
	};

	green-led {
		gpios = <&gpio2 RK_PA0 GPIO_ACTIVE_LOW>;
		label = "greenled";
		default-state = "off";
	};

	......
};
```

## 21 Efuse/Otp

### 21.1 框架支持

efuse/otp 驱动使用 misc-uclass.c 框架和标准接口。通常情况，efuse/otp 一般会有 secure 和 non-secure 之分。U-Boot 提供 non-secure 的访问，U-Boot spl 提供 secure otp 某些区域的访问。

non-secure 配置：

```
CONFIG_MISC
CONFIG_ROCKCHIP_EFUSE
CONFIG_ROCKCHIP_OTP
```

secure 配置：

```
CONFIG_SPL_MISC=y
CONFIG_SPL_ROCKCHIP_SECURE_OTP=y
```

框架代码：

```
./drivers/misc/misc-uclass.c
```

驱动代码：

```c
// non-secure:
./drivers/misc/rockchip-efuse.c
./drivers/misc/rockchip-otp.c
// secure:
./drivers/misc/rockchip-secure-otp.S
```

### 21.2 相关接口

```c
// non-secure:
int misc_read(struct udevice *dev, int offset, void *buf, int size)
// secure:
int misc_read(struct udevice *dev, int offset, void *buf, int size)
int misc_write(struct udevice *dev, int offset, void *buf, int size)
```

### 21.3 DTS 配置

以 rk3308 为例：

non-secure:

```
otp: otp@ff210000 {
	compatible = "rockchip,rk3308-otp";
	reg = <0x0 0xff210000 0x0 0x4000>;
};
```

secure:

```
secure_otp: secure_otp@0xff2a8000 {
	compatible = "rockchip,rk3308-secure-otp";
	reg = <0x0 0xff2a8000 0x0 0x4000>;
	secure_conf = <0xff2b0004>;
	mask_addr = <0xff540000>;
};
```

### 21.4 调用示例

non-secure 示例:

```c
char data[10] = {0};
struct udevice *dev;

/* retrieve the device */
ret = uclass_get_device_by_driver(UCLASS_MISC,
				  DM_GET_DRIVER(rockchip_otp), &dev);
if (ret) {
	printf("no misc-device found\n");
	return 0;
}

misc_read(dev, 0x10, &data, 10);
```

secure 示例:

```c
char data[10] = {0};
struct udevice *dev;
int i;

/* retrieve the device */
ret = uclass_get_device_by_driver(UCLASS_MISC,
				  DM_GET_DRIVER(rockchip_secure_otp), &dev);
if (ret) {
	printf("no misc-device found\n");
	return 0;
}

for (i = 0; i < 10; i++)
    data[i] = i;

misc_write(dev, 0x10, &data, 10);
memset(data, 0, 10);
misc_read(dev, 0x10, &data, 10);
```

### 21.5 Secure-Otp

RK 对 secure otp 只开放部分区域读写，区域如下：

```c
0x0;        // Rockchip 定义为 Secure boot enable flag
0x10-0x2f;  // Rockchip 定义为 RSA Public key hash
0x80-0x187; // Rockchip 定义为 reserved for OEM
```

## 22 MTD

MTD (Memory Technology Device) 即内存技术设备，支持 nand、spi nand、spi nor。RK 设计了 MTD block 层用于支持 MTD 设备的读写。

### 22.1 框架支持

U-Boot配置：

```c
// MTD驱动
CONFIG_MTD=y
CONFIG_CMD_MTDPARTS=y
CONFIG_MTD_DEVICE=y

// MTD block设备驱动
CONFIG_CMD_MTD_BLK=y
CONFIG_MTD_BLK=y

// 其他nand设备驱动config
......
```

SPL配置：

```c
CONFIG_MTD=y
CONFIG_CMD_MTDPARTS=y
CONFIG_MTD_DEVICE=y
CONFIG_SPL_MTD_SUPPORT=y

// 其他nand设备驱动config
......
```

框架代码：

```
drivers/mtd/mtd-uclass.c
drivers/mtd/mtdcore.c
drivers/mtd/mtd_uboot.c
drivers/mtd/mtd_blk.c
```

驱动为各个控制器驱动，把读写等接口挂接到 MTD 层。

### 22.2 相关接口

```c
unsigned long blk_dread(struct blk_desc *block_dev, lbaint_t start,
                        lbaint_t blkcnt, void *buffer)
```
