# **Rockchip_RK2206_User_Manual_Panic_Info_CN**

文件标识：RK-KF-YF-057

发布版本: 1.0.0

日期:2019.12

文件密级：公开资料

---

**免责声明**

本文档按“现状”提供，福州瑞芯微电子股份有限公司（“本公司”，下同）不对本文档的任何陈述、信息和内容的准确性、可靠性、完整性、适销性、特定目的性和非侵权性提供任何明示或暗示的声明或保证。本文档仅作为使用指导的参考。

由于产品版本升级或其他原因，本文档将可能在未经任何通知的情况下，不定期进行更新或修改。

**商标声明**

“Rockchip”、“瑞芯微”、“瑞芯”均为本公司的注册商标，归本公司所有。

本文档可能提及的其他所有注册商标或商标，由其各自拥有者所有。

**版权所有© 2019福州瑞芯微电子股份有限公司**

超越合理使用范畴，非经本公司书面许可，任何单位和个人不得擅自摘抄、复制本文档内容的部分或全部，并不得以任何形式传播。

福州瑞芯微电子股份有限公司

Fuzhou Rockchip Electronics Co., Ltd.

地址：     福建省福州市铜盘路软件园A区18号

网址：     [www.rock-chips.com](http://www.rock-chips.com)

客户服务电话： +86-4007-700-590

客户服务传真： +86-591-83951833

客户服务邮箱： [fae@rock-chips.com](mailto:fae@rock-chips.com)

---

## **前言**

**概述**

本文主要针对RK2206系统异常Panic问题的排查及排错脚本使用方法。

**产品版本**

| **芯片名称** | **内核版本**    |
| ------------ | --------------- |
| RK2206       | FreeRTOS V10.0.1 |

**读者对象**

本文档（本指南）主要适用于以下工程师：

技术支持工程师
软件开发工程师

---

**修订记录**

| **日期**   | **版本** | **作者**   | **修改说明**               |
| ---------- | -------- | ---------- | -------------------------- |
| 2018.12.15 | 0.03     | XiuXin Xie | 初始版本                   |
| 2019.6.27  | 0.0.4    | Cww        | 修改文档名以及客户服务邮箱 |
| 2019.12.03 | 1.0.0    | Cww        | 针对RK2206进行修改文档|

---

## **目录**

[TOC]

---

## 1 Panic信息说明

- 1 异常类型

```
**** exception type: 3
```

- 2 异常信息

```
hard  fault, HFSR: 40000000
 check mem fault, MFSR: 00000000 fffffff0
 check bus fault, BFSR: 00000082 fffffff0
 check usage fault, UFSR: 00000000
```

- 3 SP 相关信息

```
msp: 030070e0  psp: 03014500  stack(reg0): 03014500  reg4: 030070c0
```

reg0指向r0~r3、lr值，reg4指向reg0以外的registers值

- 4 各个regs值

```
r0: 00000010  r1: ffffffff  r2: 00000012  r3: 00000013
r4: 00000014  r5: 00000015  r6: 00000016  r7: 00000017
r8: 00000018  r9: 00000019  r10: 0000001a  r11: 0000001b
r12: 0000001c  r14(lr): 030526ab  r15(pc): 0305261c  xPSR: 61000000
```

- 5 函数调用信息

```
PC call-0: 0305261c: 680a e7fe b5f8 f04f 030c f04f
PC call-1: 030526a6: f7ff ffb7 4619 4622 bdf8 0000
PC call-2: 03052662: f000 f805 f04f 0116 f04f 0216
PC call-3: 03052646: f000 f805 f04f 0116 f04f 0216
PC call-4: 0305262e: f000 f803 4619 4622 bdf8 b5f8
PC call-5: 0306609e: f7ec fabf f7eb fc11 01ff eb08
```

各个可能的函数调用信息，由于没有符表，这里只是初步信息，脚本中会判断数值是否有效
PC call-0： 最后调用位置
0305261c：最后对应的地址
0305261c:后面紧跟着地址0305261c开始的信息。

- 6 各个寄存器对应的地址值

R14的值为030526ab，030526ab为地址，紧接着打印这个地址对应的一串数据。

```
r14(lr): 030526ab
  03052660: f0000522 f04ff805 f04f0116 bdf80216
  03052670: f04fb5f8 f04f0010 f04f0111 f04f0212
  03052680: f04f0313 f04f0414 f04f0515 f04f0616
  03052690: f04f0717 f04f0818 f04f0919 f04f0a1a
  030526a0: f04f0b1b f7ff0c1c 4619ffb7 bdf84622
  030526b0: 400b0000 b672b671 8008f3ef 8109f3ef
  030526c0: 0f04f01e f3efbf0c f3ef8208 e92d8209
  030526d0: 466b0ff0 f9a4f000 e8bde7fe bf000ff0
r15(pc): 0305261c
  030525d0: bf00e7fc 03067a10 03067a28 4b022222
  030525e0: 3020f853 4770611a 03067a10 f8534b03
  030525f0: 69983020 0010f000 bf004770 03067a10
  03052600: 6fca492b 0302f04f 0203ea02 e7f7b902
  03052610: 47706008 bf00e7fe 31fff04f e7fe680a
  03052620: f04fb5f8 f04f030c f04f040d f000050e
  03052630: 4619f803 bdf84622 f04fb5f8 f04f0316
  03052640: f04f0417 f0000518 f04ff805 f04f0116
```

- 7 SP信息

打印psp、msp对应的stack内的信息。

```
psp: 03014da8
  03014d90: 00000000 0305328d 00000000 030591b3
  03014da0: 400a0000 03014dcc 00000000 03014dc7

msp: 03006350
  03006340: 030128c4 00000000 a5a5a5a5 a5a5a5a5
  03006350: 03006374 0000001f 03000e78 00000000
  03006360: 00004ffc 0305226d 030521c6 61000200
```

## 2 函数调用信息-脚本使用

### 2.1 脚本原理

脚本逐个解析下面信息

```
PC call-0: 0305261c: 680a e7fe b5f8 f04f 030c f04f
PC call-1: 030526a6: f7ff ffb7 4619 4622 bdf8 0000
PC call-2: 03052662: f000 f805 f04f 0116 f04f 0216
PC call-3: 03052646: f000 f805 f04f 0116 f04f 0216
```

判断对应的地址和后面的数据是否和elf文件objdump的一致。

### 2.2 脚本使用

方法一：

```shell
./tools/debug/pc_calls_info.sh rkos_cpu2.log TestDemo.elf arm-linux-gnueabihf-objdump
```

第一个参数为对应的panic log 信息rkos_cpu2.log
第二个参数为对应的elf文件,脚本会识别.elf后缀，所以后缀要为.elf，TestDemo.elf
第三个参数为gcc objdump的执行路径：arm-none-eabi-objdump

方法二：

```shell
./tools/debug/pc_calls_info.sh rkos_cpu2.log rkos_as_file.as
```

第一个参数为对应的panic log 信息rkos_cpu2.log
第二个参数为objdump -d对应elf文件生产文件, 由于脚本会识别后缀.as,所以文件后缀一定要为.as

### 2.3 解析结果

解析出的函数信息如下：

```
PC call-0: 0305261c: 680a e7fe b5f8 f04f 030c f04f
  1023:03052618 <test_fualt>:
   305261c:     680a            ldr     r2, [r1, #0]
PC call-1: 030526a6: f7ff ffb7 4619 4622 bdf8 0000
  1010:03052670 <test_func_04>:
   30526a6:     f7ff ffb7       bl      3052618 <test_fualt>
PC call-2: 03052662: f000 f805 f04f 0116 f04f 0216
  1020:03052654 <test_func_03>:
   3052662:     f000 f805       bl      3052670 <test_func_04>
PC call-3: 03052646: f000 f805 f04f 0116 f04f 0216
  1020:03052638 <test_func_02>:
   3052646:     f000 f805       bl      3052654 <test_func_03>
PC call-4: 0305262e: f000 f803 4619 4622 bdf8 b5f8
  1020:03052620 <test_func_01>:
   305262e:     f000 f803       bl      3052638 <test_func_02>
PC call-5: 0306609e: f7ec fabf f7eb fc11 01ff eb08
  983:03066032 <ShellTask>:
   306609e:     f7ec fabf       bl      3052620 <test_func_01>
```

所以，这个异常位置时经过ShellTask()函数一级一级调用到test_fualt()

注意：
1） PC call-0 对应的信息一定是正确的。
2） PC call-n 对应的是函数调用的源头，但是打印的信息可能会有PC call-n：PC call-n+m,最后m个信息有可能是多余的，所以看脚本输出debug信息时从PC call-0往上追溯到合理的调用位置PC call-n即可。
脚本没有对多出的m进行判断（避免脚本过于复杂）。
